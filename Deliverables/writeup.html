
<!DOCTYPE html>
<html>
    <head>
        <title>CS 184 Final Project</title>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

        <link rel="stylesheet" type="text/css" href="style.css">
        <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
            <script src = "script.js"></script>
        <link href="https://fonts.googleapis.com/css?family=Assistant:200,400,600" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Fira+Sans:200" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Bad+Script|Fira+Sans|Ruluko" rel="stylesheet">
    </head>


    <body>
        <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
        <h1 align="middle">Final Project: Fire Simulator</h1>
        <h2 align="middle">Matthew Nicoletti, Jarod Kong, Aron Lloyd <h2>

        <br><br>
        <div id="abstract">
            <h2 class="subsection" align="middle">Abstract</h2>
            <p class="info"> <i>
              The main goal of this project was to attempt to experiment with new ways of simulating
              fire. State of the art fire simulations implement numerical integration of the PDEs
              that govern the motion and temperature of various gaseous substances involved in
              combustion, as well as highly sophistocated ray tracing techniques in order to
              properly render the fire. Our method allows a real-time simulation of fire
              using a randomized propagation method. The model we use is reminiscent of
              (and inspired by) interacting particle systems and random interface growth models from
              probability theory and statistical mechanics.
            </i>
            </p>
        </div>

        <div id="approach">
          <h2 class="subsection" align="middle">Technical approach</h2>
          <h3 class="subsection2" align="middle">Background</h3>
            <p class="info">
              Although our method ultimately was conceptually completely different,
              our group studied one of the most popular fire simulation methods
              to date, known as the level set method
               (cite Stam's stable fluids, and Stanford "physbam" people). For
              completeness, we outline the key steps in the method here.
            </p>
            <p class="info">
              The simulation
              uses a 3-dimensional \(N \times N \times N\) grid of voxels, embedded in world space
              with spacing \(h\) between the centers
              of the grid-faces. The algorithm keeps track of the level set function, \(\phi\),
              the pressure, \(p\), and the temperature \(T\) at the centers
              of the voxels. The algorithm also keeps track of velocity fields and densities
              for two different substances -- the fuel (inside the burning fire),
              and the hot gaseous products (in the ambient air).
              The main idea is to update the function \(\phi\) so that the interface between
              the two different substances (ie the two dimensional surface
              which is the outer boundary of the flame) is given by the level set
              \(\phi = 0\).
            </p>
            <p class="info">
              Thus, at each step of the algorithm the function \(\phi\) is
              updated so that the level surface propogates correctly,
              and also such that it, at least approximately,
               satisfies the property \(| \nabla \phi | = 1\). Further,
              for both the fuel and the hot gasses the algorithm
              updates the velocity and pressure fields so as to ensure that each
              substance separately satisfies its own set of incompressible navier stokes equations
              \(\nabla \cdot u =0\),
              \( d/dt (u) = -(u \cdot \nabla) u - \nabla p / \rho + f\),
              where here \(u\) is the velocity field, \(u \cdot \nabla\) is applied
              to each component of \(u\) separately, \(p\) is the pressure, and \(f\) is
              the external force.
            </p>

            <p class="info">
              The external forces are added directly
              via a first order Euler update, and one of the forces is for vorticity,
              which is responsible for the curling effect (ie the formation of
              small vortices) one can observe in real fire. The advection term \((u \cdot \nabla) u\)
              is integrated out using the method of characteristics, which generally can
              be used to integrate advection equations of the type
              \(d/dt (a) = (v \cdot \nabla) a\) for some velocity field
              \(v\) and some function \(a\) of space and time. Roughly, the idea is that
              along integral curves of the velocity field the function \(a\) will be constant,
              so to set \(a(t + d t, x, y, z)\), one must
              follow the velocity field back in time over time span of \(dt\),
              say to some point \((x', y', z')\) and then set
              \(a(t + dt, x, y, z) = a(t, x, y, z)\). See (Cite Stam) for details. Once we do
              this for each component of the velocity \(u\), the
              resulting field must be projected down to its divergence free part in order
              to satisfy incompressibility, and to accomplish this one must solve a poisson type
              boundary value problem for the pressure. The generic methods for doing this involve
              approximating the continuous Laplacian with a discrete graph Laplacian and
              using a fast linear solver to solve the resuling (sparse) linear system.
            </p>
            <p class="info">
                Another important idea is that due to a discontinuity in the velocity field
                nearby the boundary, care must be taken when performing the above steps
                at points near the interface. For example, if at some grid position \((i, j, k)\)
                in the fuel region I am updating the velocity, the fuel velocities are
                what should be used, but some
                of the neighbors of \((i, j, k)\) may be in the gaseous product region. Thus,
                at these points <i>ghost values</i> of the fuel velocity must be used. Formulas
                for what these ghost values should be can be derived from first principles.
            </p>
            <p class="info">
                As previously stated, the method we used was completely different.
                One possible way to view the system we have created is as a perturbed
                discrete time version of two-dimensional ASEP. ASEP is a continuous time
                Markov chain which can be thought of as a simplified model for traffic flow
                or interacting particle systems. ASEP is a very simple model, and in
                one dimesnion it is well known that as the grid mesh approaches a continuum,
                the dynamics of ASEP are governed by a Burgers type equation, which is similar
                to the advection equations used to model stable fluids. In
                ASEP, each grid cell can be either occupied by a particle, or unoccupied, and
                each particle has an exponentially distributed alarm clock, and when its
                clock goes off a particle attempts a jump to one of its neighboring squares
                (say, uniformly at random) and succeeds if no other particle is already there. Otherwise,
                it stays where it is, and either way it restarts its alarm clock.
                In our model there are also two types of grid squares, "on" or "off", and each
                grid square does a random update based only on its neighbors. However, the
                "off" particles can percolate into the "on" squares and vice versa.
            </p>


            <h3 class="subsection2" align="middle">Our Simulation Algorithm</h3>
            <p class="info">
              In order to better understand the algorithm, the shader and texture need to be explained first. The WebGL fragment shader colors our
              texture by taking a weighted sum of the neighbors' color. This allows the texture to mimic fire by having a more pronounced color on
              the edges while  the center becomes a lot brighter and whiter. The way the N x N texture is populated for the WebGL shader was by
              using a pixel N x N array. This pixel array determines whether to color a particular location on the texture depending if its value
              is 0 (off) or 255 (on). This means that in order to simulate our fire animation, the only thing that needs to be modified is the pixel
              array.
            </p>
            <p class="info">
              The mutate step works as follows: at particular point in the pixel array, check its status. For each of its neighbors
              (up, down, left, right), check if they are the opposite. If so, switch the pixel to the opposite status by
              flipping a biased coin. The coin bias depends on whether the neighbor is below or above or adjacent to the pixel.
              The parameters that determine the coin bias are
              <b>Ratio:</b> the main parameter in determining the probability that the pixel will switch, <b>Speed:</b> how fast the fire grows,
              and <b>Vertical:</b> helps the fire grow up by boosting the probability when checking the neighbor below.
            </p>
            <p class="info">
              For all the algorithms in the probabilistic implementation, each update step works by calling the mutate function on two groups.
              The two groups are determined such that each location is not neighbors with any in the same group. This is because each pixel is
              mutated based on the value of its neighbors, so the two step update prevents previous results from affecting future ones.
            </p>
            <p class="info">
              In order to improve our fire simulation, we attempted to add smoke. This involved updating the fragment shader and the mutate step.
              In the fragment shader, we placed a barrier around the fire such that if a pixel were to be turned on outside of it, the color would
              be grey. The mutate function was also updated so that on top of the original neighbor update method, if a pixel was above a certain
              height, it had a chance to turn on based on the pixels below it within a certain step size. This allowed smoke to propagate up.
            </p>

            <h3 class="subsection2" align="middle">Tribulations</h3>
            <p class="info"> One of the central issues with the system is that the simulated fire lacks
                 vortices. In the physically based method, vorticity is accounted for by
                 a term in the external force.
            </p>

            <p class="info"> In an attempt to deal with this, we added a third species of particle into the system. The idea was that
              this third type of particle would be more rare than the standard "on" and "off"
              particles, but that it would have a small local vortex around it that would
              create a swirling effect in the fire around it. This third species of particle
              propagates upwards like the other fire particles, but it has a smaller
              probability of being introduced into the system at the fuel source at the bottom.
              Our implementation of the effect of the small vortex was to literally
              rotate in a circle all of the particles inside of a small annular
              region around the vortex particle.
            </p>

            <p class="info">
              Our change did not quite have the desired effect. In general, the fire
              looks quite similar, although it overall tends to appear more chaotic
              and a little bit less natural. Another undesirable side affect is that
              occasionally the system reaches some sort of critical point and the fire
              degenerates and the particles start spreading out far too much and it stops
              looking like fire altogether. Below we have included a video to illustrate
              both of these phenomena.
            </p>
        </div>

            <h5 class = subsection2 align="middle">Shaders</h4>
        <div id = "stuff">
            <div class="shader">
                <h4 class="title">Front Propagation</h2>
                <p class="details">


                  $$\phi_t = -\vec{w}\cdot\nabla\phi$$
                  <b>Numerically:</b>
                  $$\phi^{new}=\phi^{old}-\Delta(w_1\phi_x+w_2\phi_y+w_3\phi_z)$$
                  $$\text{Where: }\vec{w}\equiv(V_f + S)\hat{n}$$
                  Here, <b>w</b> is the velocity with which the front moves.

                $$\mathbf{u}=\mathbf{w}-\nabla p$$

              </p>
              <div class="pic"><img src="assets/img/pressure.png"></div>
            </div>

            <div class="shader">
                <h4 class="title">Buoyancy/Gravity</h2>
                <p class="details">
                  Advection handles the directional dissipation of the three information f
                  $$q(\mathbf{x}, t + \delta t) = q(\mathbf{x} - \mathbf{u}(\mathbf{x}, t) \delta t, t)$$

                  Note that <b>q</b> can represents fluid properties density, velocity, and
                </p>
                <div class="pic"><img src="assets/img/advection.png"></div>
            </div>

            <div class="shader">
                <h4 class="title">Vorticity</h2>
                <p class="details">

                  We have separate shaders for each of the slabs in order to produce more customized visualizations.
                </p>
                <div class="pic"><img src="assets/img/impulse.png"></div>
            </div>

            <div class="shader">
                <h4 class="title">Advection</h2>
                <p class="details">
                  The buoyancy shader applies a force along the vertical axis. This is where the temperature slab comes into play.

                $$f_{buoy} = (-\kappa d + \sigma (T - T_0))\mathbf{\hat{j}}$$

                </p>
                <div class="pic"><img src="assets/img/buoyancy.png"></div>
            </div>

            <div class="shader">
                <h4 class="title">Pressure Gradient</h2>
                <p class="details">

                  $$\Psi = \frac{\eta }{|\eta|}, \eta = \nabla |\omega|, \omega = \nabla \times \mathbf{u}$$

                  Afterwards, we apply the restorative force

                  $$f_{vc} = \varepsilon (\Psi \times \omega) \delta x$$
                </p>

                <div class="pic"><img src="assets/img/vorticity.png"></div>
            </div>

            <div class="shader">
                <h4 class="title">BOUNDARY CONDITIONS</h2>
                <p class="details">

                  $$\frac{\mathbf{u}_{0,j}+\mathbf{u}_{1,j}}{2}=0,\mathrm{for}j\in[0, N]$$
                  $$\frac{\mathbf{p}_{1,j}-\mathbf{p}_{0,j}}{\delta x}=0$$

                </p>
                <div class="pic"><img src="assets/img/boundary.png"></div>
            </div>

            <a id="prev">&#9664;</a>
            <a id="next">&#9654;</a>
        </div>

            <video class="tab" height="350" width="425" style="display:block; margin: 0 auto; object-fit: inherit;"
             controls>Your browser does not support the &lt;video&gt; tag.
              <source src="blowup.mov"/>
            </video>
            <h2 class="subsection" align="middle">The Gem of Knowledge</h2>

            <p class="info">  jjjjj </p>
        <div id="results">
            <h2 class="subsection" align="middle">Results</h2>
            <p class="info">
              In order to achieve the best looking fires, we had to test several different combinations of the parameters.
            </p>
        </div>

        <div id="resources">
          <h2 class="subsection" align="middle">References</h2>
          <p align="middle"><a href="http://physbam.stanford.edu/~fedkiw/papers/stanford2002-02.pdf" target="_blank">Physically Based Model and Animation of Fire</a></p>
        </div>

        <div id="contributions">
          <h2 class="subsection" align"middle">Contributions</h2>
            <p class="info">

            </p>
        </div>
    </body>
=</html>
