
<!DOCTYPE html>
<html>
    <head>
        <title>CS 184 Final Project</title>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>

        <link href="https://fonts.googleapis.com/css?family=Cinzel|Julius+Sans+One|Press+Start+2P|Work+Sans" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="shistuff/swag/style.css">
        <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
            <script src = "shistuff/scrap/script.js"></script>


    </head>
    <body>
      <div id="top">
        <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
        <h1 id="title" align="middle">Final Project: Fire Simulator</h2>
  			<h3 id="names" align="middle">Matthew Nicoletti, Jarod Kong, Aron Lloyd </h2>
  			<div id=bottom-line></div>
  		</div>


        <br><br>
        <div id="abstract">
            <h2 class="subsection" align="middle">Abstract</h2>
            <p class="info"> <i>
              The main goal of this project was to attempt to experiment with new ways of simulating
              fire. State of the art fire simulations implement numerical integration of the PDEs
              that govern the motion and temperature of various gaseous substances involved in
              combustion, as well as highly sophistocated ray tracing techniques in order to
              properly render the fire. Our method allows a real-time simulation of fire
              using a randomized propagation method. The model we use is reminiscent of
              (and inspired by) interacting particle systems and random interface growth models from
              probability theory and statistical mechanics.
            </i>
            </p>
        </div>

        <div id="approach">
          <h2 class="subsection" align="middle">Technical approach</h2>
          <h3 class="subsection2" align="middle">Background</h3>
            <p class="info">
              Although our method ultimately was conceptually completely different,
              our group studied one of the most popular fire simulation methods
              to date, known as the level set method
               (<a href="http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/ns.pdf" target="_blank">Stable Fluids</a>,
                <a href="http://physbam.stanford.edu/~fedkiw/papers/stanford2002-02.pdf" target="_blank">Physically Based Model and
                  Animation of Fire</a>).
                We attempted to build this, but only after nearly completing the simulation engine, we realized that we
                lacked a proper ray-tracing engine, or time to build one. Nevertheless, here we outline the simulation.
            </p>
            <p class="info">
              The process is casted on a 3-dimensional \(N \times N \times N\) grid of voxels, embedded in world space
              with spacing \(h\) between the centers
              of the grid-faces. The algorithm keeps track of the level set function, \(\phi\),
              the pressure, \(p\), and the temperature \(T\) at the centers
              of the voxels. The algorithm also keeps track of velocity fields
              for two different substances -- the fuel (inside the burning fire),
              and the hot gaseous products (in the ambient air).
              The main idea is to update the function \(\phi\) so that the interface between
              the two different substances (ie the two dimensional surface
              which is the outer boundary of the flame) is given by the level set
              \(\phi = 0\).
            </p>
            <p class="info">
              Thus, at each step of the algorithm the function \(\phi\) is
              updated that it satisfies the property \(| \nabla \phi | = 1\).
              The Navier-Stokes equations are simplified by assuming incompressibility and neglecting
              viscous effects. The latter drops a term, while the former is upheld by:
              $$\nabla \cdot u = 0$$
              \( d/dt (u) = -(u \cdot \nabla) u - \nabla p / \rho + f\),
              where here \(u\) is the velocity field, \(u \cdot \nabla\) is applied
              to each component of \(u\) separately, \(p\) is the pressure, and \(f\) is
              the external force.
            </p>
            <p class="info">
                The boundary/reaction surface constitutes a discontinuity in the velocity field.
                Care must be taken when performing updating near the interface.
                E.g. if you are updating a point in the <b>fuel</b> region, right at the surface,
                when I query the neighboring points, I will be reaching into the <b>gaseous products</b>
                data. Thus at these points <i>ghost values</i> of the fuel data must be used.
            </p>
            <p class="info">Below we elucidate each step in calculating a single simulation frame.</p>
            <h5 class = subsection2 align="middle">Simulation Steps</h4>
            <div id = "stuff">
                <div class="terms">
                    <h4 class="title">Front Propagation</h2>
                    <p class="details">
                      The first step in each frame is to move forward the reaction boundary. This is done with a simple 1st order equation.

                      $$\phi_t = -\mathbf{w}\cdot\nabla\phi$$
                      <b>Numerically</b> this looks like:
                      $$\phi^{new}=\phi^{old}-\Delta(w_1\phi_x+w_2\phi_y+w_3\phi_z)$$
                      $$\text{Where: }\mathbf{w}\equiv(V_f + S)\mathbf{\hat{n}}$$
                      Here, <b>\(V_f\)</b> is the velocity of fuel vapor, normal to the surface. <b>S</b> is the reaction velocity.
                  </p>
                </div>

                <div class="terms">
                    <h4 class="title">Buoyancy/Gravity/Vorticity</h2>
                    <p class="details">
                      All three of these terms were included via simple first order Euler update.
                      $$F_{buoy} = \alpha(T-T_{air})\rho\hat{z}$$
                      $$F_{grav} = 9.81\rho$$
                      $$F_{conf} = \epsilon h(\mathbf{N}\times\mathbf{\omega})\rho$$
                      This last term, the <i>vorticity confinement</i> should give our fire a swirly business.
                      The vorticity field, \(\omega\), is the curl of the velocity field, while big \(N\) is just the normalized gradient field
                      of the vorticity. This is sort of a heuristic technique to create turbulence sourced on the fluid rotating,
                      and the gradient of rotations.
                    </p>
                </div>

                <div class="terms">
                    <h4 class="title">Advection</h2>
                    <p class="details">
                      The advection term \((u \cdot \nabla) u\)
                      is included via <i>Method of Characteristics</i>, which generally can
                      be used to integrate advection equations of the type
                      \(d/dt (a) = (v \cdot \nabla) a\) for some velocity field
                      \(v\) and some function \(a\) of space and time. Roughly, the idea is that
                      along integral curves of the velocity field the function \(a\) will be constant,
                      so to set \(a(t + d t, x, y, z)\), one must
                      follow the velocity field back in time over time span of \(dt\),
                      say to some point \((x', y', z')\) and then set
                      \(a(t + dt, x, y, z) = a(t, x, y, z)\). See (Cite Stam) for details. Once we do
                      this for each component of the velocity \(u\), the
                      resulting field must be projected down to its divergence free part in order
                      to satisfy the earlier conjectured incompressibility...<i>right arrow</i>

                    </p>
                </div>

                <div class="terms">
                    <h4 class="title">Pressure Gradient</h2>
                    <p class="details">
                      ...and to accomplish this one must solve a poisson type
                      boundary value problem for the pressure.
                      $$\nabla^2p = \rho\frac{h}{\Delta t}\nabla\cdot\mathbf{u}$$
                      The generic methods for doing this involve
                      approximating the continuous Laplacian with a discrete graph Laplacian
                      $$\sum_{n\in\{xyz\}}p_n -6p = \rho\frac{h}{\Delta t}\sum_{n\in\{xyz\}}(u_{n+1}-u_n)$$
                      and using a fast linear solver to solve the resuling (sparse) linear system.
                      We built and passed this matrix into an Eigen library Conjugate Gradient algorithm.
                      The point is that whenever the velocity field exhibits any induced divergence (from the previous terms), then
                      instead of having mass build up/dissipate from positions in space, we instead displace the effect into
                      the pressure field. We solve pressure s.t. it acts as an equal-n-opposite force to any forces causing divergence.
                      $$\mathbf{u}=\mathbf{u^*}-\Delta t\frac{\nabla\cdot p}{\rho}$$
                      Our final velocity field will then be void of divergence.
                    </p>

                </div>
                <div class="terms">
                    <h4 class="title">Surface Discontinuities</h2>
                    <p class="details">
                    We patch together the two sides of the surface with the well established
                    <b>Rankine-Hugoniot jump conditions</b>
                    $$\rho_f(V_f - D) = \rho_p(V_p - D)$$
                    $$\rho_f(V_f - D)^2 + p_f= \rho_p(V_p - D)^2 + p_p$$
                    $$D\equiv V_f - S$$
                    The big \(V\)'s are the normal components of velocity for the <b>fuel</b> and
                    <b>products</b> respectively.
                    The first equation updholds conservation of mass, the second conservation of Momentum.
                    If one finds themselves querying data from the incorrect set of velocities, one can solve for
                    the <i>ghost-value</i> of the correct velocity.
                    </p>
                </div>

                <a id="prev">&#9664;</a>
                <a id="next">&#9654;</a>
            </div>

            <p class="info">
                Unfortunately, we could not achieve success with the thorough method.
                Fortunately, we <b>did</b> find success via an alternative route.
                One possible way to view the system we have created is as a perturbed
                discrete time version of two-dimensional ASEP. ASEP is a continuous time
                Markov chain which can be thought of as a simplified model for traffic flow
                or interacting particle systems. ASEP is a very simple model, and in
                one dimension it is well known that as the grid mesh approaches a continuum,
                the dynamics of ASEP are governed by a Burgers type equation, which is similar
                to the advection equations used to model stable fluids. In
                ASEP, each grid cell can be either occupied by a particle, or unoccupied, and
                each particle has an exponentially distributed alarm clock, and when its
                clock goes off a particle attempts a jump to one of its neighboring squares
                (say, uniformly at random) and succeeds if no other particle is already there. Otherwise,
                it stays where it is, and either way it restarts its alarm clock.
                In our model there are also two types of grid squares, "on" or "off", and each
                grid square does a random update based only on its neighbors. However, the
                "off" particles can percolate into the "on" squares and vice versa.
            </p>


            <h3 class="subsection2" align="middle">Our Simulation Algorithm</h3>
            <p class="info">
              In order to better understand the algorithm, the shader and texture need to be explained first.
              The WebGL fragment shader colors our texture by taking a weighted sum of the neighbors' color.
              This allows the texture to mimic fire by having a more pronounced color on the edges while  the
              center becomes a lot brighter and whiter. The way the N x N texture is populated for the WebGL
              shader was by using a pixel N x N array. This pixel array determines whether to color a
              particular location on the texture depending if its value is 0 (off) or 255 (on). This means
              that in order to simulate our fire animation, the only thing that needs to be modified is the
              pixel array.
            </p>
            <p class="info">
              The mutate step works as follows: at particular point in the pixel array, check its status. For each of its neighbors
              (up, down, left, right), check if they are the opposite. If so, switch the pixel to the opposite status by
              flipping a biased coin. The coin bias depends on whether the neighbor is below or above or adjacent to the pixel.
              The parameters that determine the coin bias are
              <b>Ratio:</b> the main parameter in determining the probability that the pixel will switch, <b>Speed:</b> how fast the fire grows,
              and <b>Vertical:</b> helps the fire grow up by boosting the probability when checking the neighbor below.
            </p>
            <p class="info">
              For all the algorithms in the probabilistic implementation, each update step works by calling the mutate function on two groups.
              The two groups are determined such that each location is not neighbors with any in the same group. This is because each pixel is
              mutated based on the value of its neighbors, so the two step update prevents previous results from affecting future ones.
            </p>
            <p class="info">
              In order to improve our fire simulation, we attempted to add smoke. This involved updating the fragment shader and the mutate step.
              In the fragment shader, we placed a barrier around the fire such that if a pixel were to be turned on outside of it, the color would
              be grey. The mutate function was also updated so that on top of the original neighbor update method, if a pixel was above a certain
              height, it had a chance to turn on based on the pixels below it within a certain step size. This allowed smoke to propagate up.
            </p>

            <h3 class="subsection2" align="middle">Tribulations</h3>
            <p class="info"> One of the central issues with the system is that the simulated fire lacks
                 vortices. In the physically based method, vorticity is accounted for by
                 a term in the external force.
            </p>

            <p class="info"> In an attempt to deal with this, we added a third species of particle into the system. The idea was that
              this third type of particle would be more rare than the standard "on" and "off"
              particles, but that it would have a small local vortex around it that would
              create a swirling effect in the fire around it. This third species of particle
              propagates upwards like the other fire particles, but it has a smaller
              probability of being introduced into the system at the fuel source at the bottom.
              Our implementation of the effect of the small vortex was to literally
              rotate in a circle all of the particles inside of a small annular
              region around the vortex particle.
            </p>

            <p class="info">
              Our change did not quite have the desired effect. In general, the fire
              looks quite similar, although it overall tends to appear more chaotic
              and a little bit less natural. Another undesirable side affect is that
              occasionally the system reaches some sort of critical point and the fire
              degenerates and the particles start spreading out far too much and it stops
              looking like fire altogether. Below we have included a video to illustrate
              both of these phenomena (if the video is not working in Chrome try firefox, please).
            </p>
        </div>
        <video class="tab" height="350" width="425" style="display:block; margin: 0 auto; object-fit: inherit;"
         controls>Your browser does not support the &lt;video&gt; tag.
          <source src="shistuff/vads/blowup.mov"/>
        </video>


        <h2 class="subsection" align="middle">Gems of Knowledge</h2>
        <p class="info">
          One thing we learned is that simplicity can be powerful.
          We conjecture that our attempt at creating
              vorticity, in a very rough sense, added too much complexity into the system,
              disrupting its stability. The model which looked the most like fire
              was the simplest one with only the basic particle propogation rules.
              Making a probabilistic model such that there is a stationary distribution where
              something interesting happens is a subtle thing.

          Secondly, numerical simulation was new to us (beyond the cloth model). It is amazing that,
          when one captures the essence of a natural system, then takes small enough steps with their
          computation machines along the paths dictated by our approximate equations of dynamics;
          the reproduction is astoundingly reminiscent of nature's chaos.
          Another thing, we learned something about the importance of open-source software. One does
          not always want to write their own sparse matrix inverting algorithms.
          Lastly, practicality ought to be held higher in respect over wild ambition.
          Nevertheless, we will continue our fire endeavors in order to someday attain high quality
          physically based, 3-dimensional renditions of fire.
        </p>


             <p class="info">
               We also learned a lot about fluid dynamics, interacting particle systems,
               WebGL, and methods of integrating differential equations (such as the
               method of characteristics for Burgers type equations).
              </p>

        <div id="results">
            <h2 class="subsection" align="middle">Results</h2>
            <p class="info">
              In order to achieve the best looking fires, we had to test several different combinations of the parameters.
            </p>
            <div align="center"><p>Fire with Ratio:0.4, Speed:0.1, Vertical_Ratio:10:</p></div>
            <video class="tab" height="350" width="425" style="display:block; margin: 0 auto; object-fit: inherit;"
               controls>Your browser does not support the &lt;video&gt; tag.
                <source src="shistuff/vads/fire_best.mov"/>
            </video>
            <div align="center"><p>Smoke Simulation Added:</p></div>
            <video class="tab" height="350" width="425" style="display:block; margin: 0 auto; object-fit: inherit;"
             controls>Your browser does not support the &lt;video&gt; tag.
              <source src="shistuff/vads/smoke.mov"/>
            </video>
        </div>

        <div id="resources">
          <h2 class="subsection" align="middle">References</h2>
          <p align="middle"><a href="http://physbam.stanford.edu/~fedkiw/papers/stanford2002-02.pdf" target="_blank">Physically Based Model and Animation of Fire</a></p>
          <p align="middle"><a href="http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/ns.pdf" target="_blank">Stable Fluids</a></p>
          <p align="middle"><a href="https://math.berkeley.edu/~sethian/2006/Papers/sethian.vonkarman_1.pdf" target="_blank">Fast Marching & Level Set</a></p>
          <p align="middle"><a href="http://gamma.cs.unc.edu/FRAC/laplacian_large.pdf" target="_blank">Fast Simulation of Laplacian Growth</a></p>
        </div>

        <div id="resources">
          <h2 class="subsection" align="middle">Video Link</h2>
          <p align="middle"><a href="https://www.youtube.com/watch?v=bnS1Wors3FU&feature=youtu.be" target="_blank">CS184 Final Project Video</a></p>
        </div>

        <div id="contributions">
          <h2 class="subsection" align"middle">Contributions</h2>
          <p class="info">
            <b>Matthew:</b>
          Helped with development of the WebGL algorithm and attempted to change the mutation step to add vorticity.
             Experimented with parameters to find the best looking results. Understood papers on physically based simulation
             techniques. Made lightning simulation as part of further experimentation.
              Worked on writeup for milestone and final deliverable.
          </p>
          <p class="info">
            <b>Jarod:</b> Primarily worked on WebGL application. Helped with development of algorithm and implemented the smoke changes to the shaders and the mutation steps. Experimented with parameters to find the best looking results. Worked on video production for milestone and final deliverable.
          </p>
          <p class="info">
            <b>Aron: Sorry, this was the only thing commited past the due date! I'm the sad soul who proposed endeavoring the
            full-blown, 3D physically based simulation, only to watch it be left in the trenches. I wrote in all the boundary conditions, discontinuity fixes
            surface normalized gradient field update, poisson solver integration, and built initial environments. The majority of css stylization was my hand as well.</b>
          </p>
        </div>

        <h2 class="subsection" align="middle">Extras</h2>
          <h3 class="subsection" align="middle">Lightning</h3>
        <p class="info">
        As a part of our exploration of using random systems to generate
        dynamics for physical processes, we experimented with simulations
        of lightning. The simulation algorithm is from
        (<a href="http://gamma.cs.unc.edu/FRAC/laplacian_large.pdf" target="_blank">Fast Simulation of Laplacian Growth</a>),
        and it is meant to
        approximate the following situation:
        Place a small conducting sphere at the origin, and a large
        concentric positively charged spherical
        shell around the origin. The surface of the small conductor can expand randomly
        in any direction, and the distribution of where this expansion happens is proportional
        to the electric potential at this point. This potential is given by
        the inverse of the Laplacian operator, or in other words by a greens function,
        and these small changes in the shape of the conductor can create an
        unstable feedback loop, which ultimately causes
        large streaks of the conductor to grow and
        branch out in a lighting-like way. We implemented the algorithm, and without
        any processing to make it render nicely, this is our result.
        </p>

       <video class="tab" height="350" width="425" style="display:block; margin: 0 auto; object-fit: inherit;"
        controls>Your browser does not support the &lt;video&gt; tag.
         <source src="lightning.mov"/>
       </video>
      </div>
    </body>
</html>
