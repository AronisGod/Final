<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
    div.padded {
      padding-top: 0px;
      padding-right: 100px;
      padding-bottom: 0.25in;
      padding-left: 100px;
    }
  </style>
<title>Aron Lloyd |  CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
<br>
<h1 align="middle">Fire and the Flames</h1>
    <h2 align="middle">Team :</h2>
    <h2 align="middle">Matthew Nicoletti, Jarod Kong, Aron Lloyd</h2>
    >


    <div class="padded">
    <h2 align="middle">Progress Summary</h2>
      <p>  We aimed to construct an algorithm which can model the dynamics of fire for rendering purposes.
        Fire is a chaotic an unruly natural process, which can be difficult to simulate on the rectangular framework of
        numerical computations.
        We experimented with ways of rendering fire that circumvent the expensive
        (numerical) integration of PDEs,
         grid sampling, and complicated
        ray tracing techniques.
        One way we hoped to do this was to try to exploit
        the dynamics exhibited by certain simplified probabilistic lattice models
        in their "scaling limits"; or in other words, as the granularity of the lattice approaches
        a continuum. As a result of our initial trajectory, we have thus far created a 2-dimensional rendering of fire
        using simple probabilistic update rules for the propogation of the flame. Simplicity was prioritized so we could achieve real-time animation.
        This was also the motivation for using a shader for GPU computations.
        We describe this achievement below.</p>


      <h2 align="middle">The Algorithm</h2>
        <p> The model is a markov chain on a N x N lattice;
        inspired by lattice models in statistical mechanics, such as the ising model and
        abelian sandpile model. In the algorithm below, i is a vertical coordinate
        and j is a horizontal coordinate, where (0,0) is the bottom left corner (i.e. (j, i) is a discrete sample of (x, y)-space).</p>

          <ol>
            <li>Iniitialize an N by N array into variable 'pixel'.
                Array elements can either be 'on' or 'off', which we denote by 1, or 0.
                Set all bottom sites (where i=0) to 'on'; this is the "source" of our flame.
                Initialize parameters p, q, s within the range [0,1] exclusive
                (these will be used as coin flip probabilities).
            </li>

            <li>(Imagine the pixel squares as a chess board). First iterate over each
              white square (j, i) in the texture.
              <ul>
                <li>
                  Case 1 - (j, i) is 'off': then
                  <ul>
                    <li>
                       If pixel(j, i-1) is 'on', set (j, i) to 'on' with probability q
                    </li>
                      <li>
                         Iterate through other adjecent neighbors (j', i'). If
                         (j', i') is on, set (j, i) to 'on' with probability p.
                      </li>

                    </ul>


                  </li>

                <li>
                  Case 2 - pixel(j, i) is 'on': then iterate through each neighbor (j', i'),
                  and if (j', i') is off, set (j, i) to off with probability s.
                </li>
              </ul>

            Reapeat this for the black squares</li>
            <li>Suppose we have a pixel (j, i) corresponding to a fragment.
              Then, in the fragment shader,
              we set the color of the fragment to
              $$0.2 * 255 * pixel(j, i) +
              0.25 * 255 * pixel(j, i + 10) +
              0.25 * 255 * pixel(j, i - 10) +
              0.25 * 255 * pixel(j - 10, i) +
              0.25 * 255 * pixel(j + 10, i) $$
            </li>
            <li>Repeat step 2.</li>

          </ol>




    <h2 align="middle">Brief Analysis</h2>
        <p>
          For each frame, the algorithm iterates through all N^2 "pixels" in the array (where N is the width and height of the texture),
          thereby the complexity scales in the size of our array.
        </p>

        <p>
          Why does this make realistic-looking fire? Well, showing equivalencies between our model and the true dynamics is not practical;
          the difference in resolutions is too large.
          Nonetheless, we provide a heuristic explaination regarding success of our result.
          The physical process of fire burning is, roughly speaking, a local process;
          meaning that the time evolution of a point in space only depends on data
          coming from points that are nearby. Furthermore, it should be roughly
          second order in space. We attempt to capture this by
          updating each pixel conditioned on the state of its four
          nearest neighbors.
        </p>

    <h2 align="middle">Updated Plan</h2>
      <p>In the next two weeks we plan on following two different approaches. Firstly, we intend to extend into 3 dimensions and refine our color shading scheme. Other aspirations
        include smoke & spark production. We will only push the complexity within the limits of what a GPU can handle in real-time rendering.
        The second approach swaps the strengths & weaknesses of the first approach, i.e. the model is significantly more elaborate, as well as significantly slower
        to calculate/render. We partition space into a grid of fixed volume "voxels". We produce fire by "burning" a vaporized fuel. This fuel is simulated via incompressible
        Navier-Stokes equations. The gaseous combustion products modeled by the same equations. An "implicit barrier" is tracked, which separates the fuel from the products,
        being an important tool in rendering the contour of the flame. The barrier is propagated through space with a "Level Set Method" and "Fast Marching" algorithms which
        focus on gird points near the barrier. The barrier moves only in the direction normal to its surface, with speed dependant on the flux, reaction rate, and curvature.</p>
      <p>We intend to compare relative pros and cons between our approaches in terms of speed and detail.</p>


      <h2 align="middle">Video and Slides</h2>

      <a href = https://youtu.be/WVXxh6fpPmk>Milestone Video</a>
      <p></p>
      <a href = https://docs.google.com/presentation/d/1s6Y9cAHmfZ7fpVpd2CDm2EfvZVQLYk-QJ-gpZcCkMCk/edit?usp=sharing>Slides</a>


</div>
</body>
</html>
